// Code by SeÃ¡n McConnon
//Comments generated by ChatGPT
import React, { useState, useEffect } from "react";
import { auth, db } from "../firebase"; // Import Firebase authentication and database
import {
  collection,
  addDoc,
  query,
  where,
  getDocs,
  updateDoc,
  doc,
} from "firebase/firestore"; // Firestore methods for database operations
import { Dropdown, Button } from "react-bootstrap"; // Bootstrap components for UI
import { useNavigate } from "react-router-dom"; // Hook for navigation between routes

const FriendSystem = () => {
  const navigate = useNavigate(); // Allows navigation between pages
  const [friendRequests, setFriendRequests] = useState([]); // Stores pending friend requests
  const [friends, setFriends] = useState([]); // Stores list of friends
  const [userEmail, setUserEmail] = useState(""); // Input for sending friend requests
  const [message, setMessage] = useState(""); // Message for feedback (success/error)
  const [isMenuOpen, setIsMenuOpen] = useState(false); // Dropdown menu toggle state

  // Toggle dropdown menu visibility
  const toggleMenu = () => setIsMenuOpen(!isMenuOpen);

  // Sends a friend request to another user by their email
  const sendRequest = async () => {
    try {
      // Ensure the user is authenticated
      if (!auth.currentUser) {
        setMessage("You must be logged in to send a friend request.");
        return;
      }

      const fromUser = auth.currentUser.uid; // UID of the logged-in user
      const toUserEmail = userEmail; // Email of the target user

      // Query to find the target user's UID using their email
      const usersQuery = query(
        collection(db, "users"),
        where("email", "==", toUserEmail)
      );
      const userSnapshot = await getDocs(usersQuery);

      // Check if the target user exists
      if (userSnapshot.empty) {
        setMessage("No user found with that email.");
        return;
      }

      const toUser = userSnapshot.docs[0].id; // UID of the target user

      // Create a friend request in the Firestore database
      const requestRef = collection(db, "friend_requests");
      await addDoc(requestRef, {
        from_user: fromUser, // Sender's UID
        to_user: toUser, // Receiver's UID
        status: "pending", // Initial status
        timestamp: new Date(), // Timestamp of the request
      });
      setMessage("Friend request sent!");
      setUserEmail(""); // Clear the input field
    } catch (error) {
      console.error("Error sending friend request:", error.message);
      setMessage("Error sending request. Please try again.");
    }
  };

  // Fetches pending friend requests for the logged-in user
  const fetchRequests = async () => {
    try {
      const q = query(
        collection(db, "friend_requests"),
        where("to_user", "==", auth.currentUser.uid), // Requests sent to the current user
        where("status", "==", "pending") // Only fetch pending requests
      );

      const querySnapshot = await getDocs(q);
      const requests = [];

      // Process each friend request
      for (const docSnap of querySnapshot.docs) {
        const requestData = docSnap.data();

        // Fetch sender's email using their UID
        const userDoc = await getDocs(
          query(
            collection(db, "users"),
            where("__name__", "==", requestData.from_user) // Match by Firestore document ID
          )
        );
        if (!userDoc.empty) {
          const senderEmail = userDoc.docs[0].data().email; // Sender's email
          requests.push({
            id: docSnap.id, // Friend request document ID
            from_email: senderEmail, // Sender's email
            ...requestData, // Remaining request data
          });
        }
      }

      setFriendRequests(requests); // Update state with friend requests
    } catch (error) {
      console.error("Error fetching friend requests:", error.message);
    }
  };

  // Fetches the current user's list of friends
  const fetchFriends = async () => {
    try {
      const friendsRef = collection(
        db,
        "users",
        auth.currentUser.uid,
        "friends" // Subcollection for the user's friends
      );
      const querySnapshot = await getDocs(friendsRef);

      const friendsData = [];
      for (const docSnap of querySnapshot.docs) {
        const friendId = docSnap.data().friend_id;

        // Fetch friend's email using their UID
        const friendDoc = await getDocs(
          query(collection(db, "users"), where("__name__", "==", friendId))
        );
        if (!friendDoc.empty) {
          const friendEmail = friendDoc.docs[0].data().email; // Friend's email
          friendsData.push({ friend_id: friendId, friend_email: friendEmail });
        }
      }

      setFriends(friendsData); // Update state with friends list
    } catch (error) {
      console.error("Error fetching friends:", error.message);
    }
  };

  // Handles accepting or declining a friend request
  const handleRequestAction = async (requestId, action) => {
    try {
      const requestRef = doc(db, "friend_requests", requestId); // Reference to the friend request document
      if (action === "accept") {
        await updateDoc(requestRef, { status: "accepted" }); // Update status to accepted

        // Add to friends list for both users
        const request = friendRequests.find((req) => req.id === requestId);
        const userFriendsRef = collection(
          db,
          "users",
          auth.currentUser.uid,
          "friends"
        );
        await addDoc(userFriendsRef, { friend_id: request.from_user });

        const senderFriendsRef = collection(
          db,
          "users",
          request.from_user,
          "friends"
        );
        await addDoc(senderFriendsRef, { friend_id: auth.currentUser.uid });
      } else {
        await updateDoc(requestRef, { status: "declined" }); // Update status to declined
      }

      // Refresh friend requests and friends list
      fetchRequests();
      fetchFriends();
    } catch (error) {
      console.error("Error updating friend request:", error.message);
    }
  };

  // Fetch friend requests and friends list when the component mounts
  useEffect(() => {
    fetchRequests();
    fetchFriends();
  }, []);

  return (
    <div className="container">
      {/* Navigation Menu */}
      <div className="d-flex align-items-center justify-content-start my-4 gap-3">
        <h2 className="mb-0">Friends </h2>
        <div className="text-center">
          <Button variant="primary" onClick={toggleMenu}>
            Menu
          </Button>
          {isMenuOpen && (
            <Dropdown.Menu show>
              <Dropdown.Item onClick={() => navigate("/dashboard")}>
                Dashboard
              </Dropdown.Item>
              <Dropdown.Item onClick={() => navigate("/profile")}>
                Profile
              </Dropdown.Item>
              <Dropdown.Item onClick={() => navigate("/receipts")}>
                Receipts
              </Dropdown.Item>
              <Dropdown.Item
                onClick={() => navigate("/investment-questionnaire")}
              >
                Investment Questionnaire
              </Dropdown.Item>
              <Dropdown.Item onClick={() => navigate("/settings")}>
                Settings
              </Dropdown.Item>
              <Dropdown.Item onClick={() => auth.signOut()}>
                Log Out
              </Dropdown.Item>
            </Dropdown.Menu>
          )}
        </div>
      </div>

      {/* Send Friend Request */}
      <div className="card mb-4 p-3">
        <h4>Send a Friend Request</h4>
        <div className="input-group">
          <input
            type="text"
            className="form-control"
            placeholder="Enter user's email"
            value={userEmail}
            onChange={(e) => setUserEmail(e.target.value)}
          />
          <button onClick={sendRequest} className="btn btn-primary">
            Send Request
          </button>
        </div>
        {message && <p className="mt-2 text-success">{message}</p>}
      </div>

      {/* Friend Requests */}
      <div className="card mb-4 p-3">
        <h4>Friend Requests</h4>
        {friendRequests.length > 0 ? (
          friendRequests.map((request) => (
            <div
              key={request.id}
              className="d-flex justify-content-between align-items-center border-bottom py-2"
            >
              <p className="mb-0">From: {request.from_email}</p>
              <div>
                <button
                  onClick={() => handleRequestAction(request.id, "accept")}
                  className="btn btn-success btn-sm me-2"
                >
                  Accept
                </button>
                <button
                  onClick={() => handleRequestAction(request.id, "decline")}
                  className="btn btn-danger btn-sm"
                >
                  Decline
                </button>
              </div>
            </div>
          ))
        ) : (
          <p>No pending friend requests.</p>
        )}
      </div>

      {/* Friends List */}
      <div className="card p-3">
        <h4>Friends List</h4>
        {friends.length > 0 ? (
          friends.map((friend, index) => (
            <p key={index} className="border-bottom py-2">
              {friend.friend_email}
            </p>
          ))
        ) : (
          <p>You have no friends yet.</p>
        )}
      </div>
    </div>
  );
};

export default FriendSystem;
